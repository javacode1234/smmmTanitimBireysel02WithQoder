"use client"

import { useState, useMemo } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { FileText, Check, AlertCircle, Calendar as CalendarIcon } from "lucide-react"
import { toast } from "sonner"

interface DeclarationSetting {
  type: string
  enabled: boolean
  frequency: 'monthly' | 'quarterly' | 'yearly'
  dueDay: number
  dueHour: number
  dueMinute: number
  dueMonth?: number
  quarterOffset?: number
  yearlyCount?: number
  skipQuarter?: number
}

interface Declaration {
  id: string
  type: string
  period: string
  periodStart: string
  periodEnd: string
  dueDate: string
  status: 'pending' | 'submitted' | 'overdue'
  submittedDate: string | null
  isAutoGenerated?: boolean
}

interface DeclarationsTrackerProps {
  declarations: Declaration[]
  declarationSettings: DeclarationSetting[]
  customerId: string
  onUpdate: (declarations: Declaration[]) => void
}

export function DeclarationsTracker({ declarations, declarationSettings, customerId, onUpdate }: DeclarationsTrackerProps) {
  const [isMarkSubmittedOpen, setIsMarkSubmittedOpen] = useState(false)
  const [selectedDeclaration, setSelectedDeclaration] = useState<Declaration | null>(null)
  const [submittedDate, setSubmittedDate] = useState("")
  
  // Filtreler
  const [yearFilter, setYearFilter] = useState<string>(new Date().getFullYear().toString())
  const [monthFilter, setMonthFilter] = useState<string>("all")
  const [typeFilter, setTypeFilter] = useState<string>("all")
  const [statusFilter, setStatusFilter] = useState<string>("all")

  const enabledDeclarationTypes = declarationSettings
    .filter(s => s.enabled)
    .map(s => s.type)

  // Otomatik dönem oluşturma
  const generateDeclarations = useMemo(() => {
    const generated: Declaration[] = []
    const currentYear = parseInt(yearFilter)
    const startYear = currentYear - 1
    const endYear = currentYear + 1

    declarationSettings.forEach(setting => {
      if (!setting.enabled) return

      // AYLIK
      if (setting.frequency === 'monthly') {
        for (let year = startYear; year <= endYear; year++) {
          for (let month = 0; month < 12; month++) {
            const periodStart = new Date(year, month, 1)
            const periodEnd = new Date(year, month + 1, 0)
            const dueDate = new Date(year, month + 1, setting.dueDay, setting.dueHour, setting.dueMinute)
            
            const monthNames = ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran',
                              'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık']
            
            generated.push({
              id: `auto-${setting.type}-${year}-${month}`,
              type: setting.type,
              period: `${monthNames[month]} ${year}`,
              periodStart: periodStart.toISOString(),
              periodEnd: periodEnd.toISOString(),
              dueDate: dueDate.toISOString(),
              status: 'pending',
              submittedDate: null,
              isAutoGenerated: true
            })
          }
        }
      }

      // 3 AYLIK
      if (setting.frequency === 'quarterly') {
        for (let year = startYear; year <= endYear; year++) {
          const quarters = [
            { start: new Date(year, 0, 1), end: new Date(year, 2, 31), name: 'Q1', num: 1 },
            { start: new Date(year, 3, 1), end: new Date(year, 5, 30), name: 'Q2', num: 2 },
            { start: new Date(year, 6, 1), end: new Date(year, 8, 30), name: 'Q3', num: 3 },
            { start: new Date(year, 9, 1), end: new Date(year, 11, 31), name: 'Q4', num: 4 },
          ]

          quarters.forEach(quarter => {
            if (setting.skipQuarter && quarter.num === setting.skipQuarter) {
              return
            }

            const offset = setting.quarterOffset || 1
            const dueMonth = quarter.end.getMonth() + offset
            const dueYear = quarter.end.getFullYear() + Math.floor(dueMonth / 12)
            const dueDateCalc = new Date(dueYear, dueMonth % 12, setting.dueDay, setting.dueHour, setting.dueMinute)

            generated.push({
              id: `auto-${setting.type}-${year}-${quarter.name}`,
              type: setting.type,
              period: `${quarter.name} ${year}`,
              periodStart: quarter.start.toISOString(),
              periodEnd: quarter.end.toISOString(),
              dueDate: dueDateCalc.toISOString(),
              status: 'pending',
              submittedDate: null,
              isAutoGenerated: true
            })
          })
        }
      }

      // YILLIK
      if (setting.frequency === 'yearly') {
        for (let year = startYear; year <= endYear; year++) {
          const periodStart = new Date(year, 0, 1)
          const periodEnd = new Date(year, 11, 31)
          const dueMonth = (setting.dueMonth || 1) - 1
          const dueDate = new Date(year + 1, dueMonth, setting.dueDay, setting.dueHour, setting.dueMinute)

          generated.push({
            id: `auto-${setting.type}-${year}`,
            type: setting.type,
            period: `${year}`,
            periodStart: periodStart.toISOString(),
            periodEnd: periodEnd.toISOString(),
            dueDate: dueDate.toISOString(),
            status: 'pending',
            submittedDate: null,
            isAutoGenerated: true
          })
        }
      }
    })

    return generated
  }, [declarationSettings, yearFilter])

  // Kullanıcı verilerini birleştir
  const allDeclarations = useMemo(() => {
    const merged = [...generateDeclarations]
    
    declarations.forEach(userDecl => {
      const index = merged.findIndex(d => 
        d.type === userDecl.type && 
        d.period === userDecl.period
      )
      
      if (index >= 0) {
        merged[index] = {
          ...merged[index],
          ...userDecl,
          isAutoGenerated: false
        }
      }
    })

    return merged
  }, [generateDeclarations, declarations])

  const handleMarkAsSubmitted = (declaration: Declaration) => {
    setSelectedDeclaration(declaration)
    setSubmittedDate(new Date().toISOString().split('T')[0])
    setIsMarkSubmittedOpen(true)
  }

  const confirmMarkAsSubmitted = () => {
    if (!selectedDeclaration) return

    const existingIndex = declarations.findIndex(d => 
      d.type === selectedDeclaration.type && 
      d.period === selectedDeclaration.period
    )

    let updated
    if (existingIndex >= 0) {
      updated = declarations.map((d, i) => 
        i === existingIndex 
          ? { ...d, status: 'submitted' as const, submittedDate: new Date(submittedDate).toISOString() }
          : d
      )
    } else {
      updated = [
        ...declarations,
        {
          ...selectedDeclaration,
          id: Date.now().toString(),
          status: 'submitted' as const,
          submittedDate: new Date(submittedDate).toISOString(),
          isAutoGenerated: false
        }
      ]
    }

    onUpdate(updated)
    setIsMarkSubmittedOpen(false)
    setSelectedDeclaration(null)
    toast.success("Beyanname verildi olarak işaretlendi")
  }

  const getDeclarationStatus = (declaration: Declaration): 'pending' | 'submitted' | 'overdue' => {
    if (declaration.status === 'submitted') return 'submitted'
    
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const due = new Date(declaration.dueDate)
    due.setHours(0, 0, 0, 0)
    
    return today > due ? 'overdue' : 'pending'
  }

  const getStatusBadge = (declaration: Declaration) => {
    const currentStatus = getDeclarationStatus(declaration)
    
    switch (currentStatus) {
      case 'submitted':
        return (
          <span className="inline-flex items-center gap-1 px-2 py-1 rounded text-xs font-semibold bg-green-100 text-green-800">
            <Check className="h-3 w-3" />
            Verildi
          </span>
        )
      case 'overdue':
        return (
          <span className="inline-flex items-center gap-1 px-2 py-1 rounded text-xs font-semibold bg-red-100 text-red-800">
            <AlertCircle className="h-3 w-3" />
            Gecikmiş
          </span>
        )
      default:
        return (
          <span className="inline-flex items-center gap-1 px-2 py-1 rounded text-xs font-semibold bg-yellow-100 text-yellow-800">
            <CalendarIcon className="h-3 w-3" />
            Bekliyor
          </span>
        )
    }
  }

  // Filtrele
  const filteredDeclarations = useMemo(() => {
    return allDeclarations.filter(decl => {
      if (typeFilter !== "all" && decl.type !== typeFilter) return false
      if (monthFilter !== "all") {
        const declMonth = new Date(decl.periodStart).getMonth()
        if (declMonth !== parseInt(monthFilter)) return false
      }
      if (statusFilter !== "all") {
        const currentStatus = getDeclarationStatus(decl)
        if (currentStatus !== statusFilter) return false
      }
      return true
    }).sort((a, b) => {
      return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()
    })
  }, [allDeclarations, typeFilter, monthFilter, statusFilter])

  const yearOptions = useMemo(() => {
    const current = new Date().getFullYear()
    return [
      (current - 1).toString(),
      current.toString(),
      (current + 1).toString()
    ]
  }, [])

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <div>
          <p className="text-sm text-muted-foreground">
            Dönemsel beyanname veriliş takibi (Otomatik oluşturulmuş)
          </p>
          {enabledDeclarationTypes.length === 0 && (
            <p className="text-xs text-amber-600 mt-1">
              ⚠️ Lütfen önce "Ayarlar" sekmesinden beyanname seçin
            </p>
          )}
          {filteredDeclarations.length > 0 && (
            <p className="text-xs text-muted-foreground mt-1">
              Toplam {filteredDeclarations.length} dönem gösteriliyor
            </p>
          )}
        </div>
      </div>

      {/* Filtreler */}
      {enabledDeclarationTypes.length > 0 && (
        <div className="flex flex-wrap gap-3">
          <div className="w-32">
            <Label className="text-xs">Yıl</Label>
            <Select value={yearFilter} onValueChange={setYearFilter}>
              <SelectTrigger className="h-9">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {yearOptions.map(year => (
                  <SelectItem key={year} value={year}>{year}</SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="w-40">
            <Label className="text-xs">Ay</Label>
            <Select value={monthFilter} onValueChange={setMonthFilter}>
              <SelectTrigger className="h-9">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Tüm Aylar</SelectItem>
                <SelectItem value="0">Ocak</SelectItem>
                <SelectItem value="1">Şubat</SelectItem>
                <SelectItem value="2">Mart</SelectItem>
                <SelectItem value="3">Nisan</SelectItem>
                <SelectItem value="4">Mayıs</SelectItem>
                <SelectItem value="5">Haziran</SelectItem>
                <SelectItem value="6">Temmuz</SelectItem>
                <SelectItem value="7">Ağustos</SelectItem>
                <SelectItem value="8">Eylül</SelectItem>
                <SelectItem value="9">Ekim</SelectItem>
                <SelectItem value="10">Kasım</SelectItem>
                <SelectItem value="11">Aralık</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="flex-1 min-w-[200px]">
            <Label className="text-xs">Beyanname Türü</Label>
            <Select value={typeFilter} onValueChange={setTypeFilter}>
              <SelectTrigger className="h-9">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Tüm Beyannameler</SelectItem>
                {enabledDeclarationTypes.map((type: string) => (
                  <SelectItem key={type} value={type}>{type}</SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="w-40">
            <Label className="text-xs">Durum</Label>
            <Select value={statusFilter} onValueChange={setStatusFilter}>
              <SelectTrigger className="h-9">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Tümü</SelectItem>
                <SelectItem value="pending">Bekliyor</SelectItem>
                <SelectItem value="submitted">Verildi</SelectItem>
                <SelectItem value="overdue">Gecikmiş</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
      )}

      {/* Tablo */}
      {filteredDeclarations.length > 0 ? (
        <div className="border rounded-lg">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Beyanname Türü</TableHead>
                <TableHead>Dönem</TableHead>
                <TableHead>Son Verme Tarihi</TableHead>
                <TableHead>Durum</TableHead>
                <TableHead>Verilme Tarihi</TableHead>
                <TableHead className="text-right">İşlemler</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredDeclarations.map((declaration, index) => (
                <TableRow key={declaration.id || `declaration-${index}`}>
                  <TableCell className="font-medium">
                    <div className="flex items-center gap-2">
                      <FileText className="h-4 w-4 text-primary" />
                      {declaration.type}
                    </div>
                  </TableCell>
                  <TableCell>{declaration.period}</TableCell>
                  <TableCell>
                    {new Date(declaration.dueDate).toLocaleDateString('tr-TR', {
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit'
                    })}
                  </TableCell>
                  <TableCell>
                    {getStatusBadge(declaration)}
                  </TableCell>
                  <TableCell>
                    {declaration.submittedDate
                      ? new Date(declaration.submittedDate).toLocaleDateString('tr-TR')
                      : '-'}
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-2">
                      {getDeclarationStatus(declaration) !== 'submitted' && (
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleMarkAsSubmitted(declaration)}
                          className="bg-green-50 hover:bg-green-100"
                        >
                          <Check className="h-3 w-3 mr-1 text-green-600" />
                          Verildi
                        </Button>
                      )}
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      ) : (
        <div className="text-center py-12 border rounded-lg bg-muted/20">
          <FileText className="h-12 w-12 mx-auto mb-3 text-muted-foreground opacity-50" />
          {enabledDeclarationTypes.length === 0 ? (
            <>
              <p className="text-muted-foreground">Henüz beyanname seçilmemiş</p>
              <p className="text-sm text-muted-foreground mt-1">
                "Ayarlar" sekmesinden müşteri için geçerli beyannameleri seçin
              </p>
            </>
          ) : (
            <>
              <p className="text-muted-foreground">Filtre sonucunda dönem bulunamadı</p>
              <p className="text-sm text-muted-foreground mt-1">
                Filtreleri değiştirerek tekrar deneyin
              </p>
            </>
          )}
        </div>
      )}

      {/* Mark Submitted Modal */}
      <Dialog open={isMarkSubmittedOpen} onOpenChange={setIsMarkSubmittedOpen}>
        <DialogContent className="max-w-md">
          <DialogHeader className="px-6 pt-6">
            <DialogTitle>Beyanname Verildi Olarak İşaretle</DialogTitle>
            <DialogDescription>
              {selectedDeclaration && `${selectedDeclaration.type} - ${selectedDeclaration.period}`}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 px-6 py-4">
            <div>
              <Label htmlFor="submittedDate">Verilme Tarihi</Label>
              <Input
                id="submittedDate"
                type="date"
                value={submittedDate}
                onChange={(e) => setSubmittedDate(e.target.value)}
              />
            </div>
          </div>

          <DialogFooter className="px-6 pb-6">
            <Button variant="outline" onClick={() => setIsMarkSubmittedOpen(false)}>
              İptal
            </Button>
            <Button onClick={confirmMarkAsSubmitted} className="bg-green-600 hover:bg-green-700">
              Kaydet
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}
